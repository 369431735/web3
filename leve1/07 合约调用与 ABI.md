ABI 编码中的uint<M>表示什么？
答案：uint<M>表示 M 位的无符号整数，其中 M 是一个 8 的倍数，且 0 < M <= 256。

在 ABI 中，动态类型和静态类型有什么区别？
答案：静态类型的大小和位置在编码前是已知的，可以直接编码。动态类型的大小或位置在编码前可能不确定，需要在编码后的数据中单独指定。

解释函数选择器(function selector)在ABI中的用途。
答案：函数选择器用于指定调用的具体函数，它是 Keccak 哈希的某个函数签名的前 4 个字节。

在Solidity中，哪些类型不被ABI直接支持？
答案：Solidity中的元组类型不被ABI直接支持，需要特定的处理。

如何通过ABI编码调用具有多个参数的函数？
答案：通过将所有参数的编码合并，其中静态参数直接编码，动态参数先记录偏移量然后在数据部分单独编码。

什么是“严格编码模式”？
答案：严格编码模式要求编码偏移量必须很小，且数据区域不允许有重叠或间隙。

在ABI中，fixed<M>x<N>有ufixed<M>x<N>什么不同？
答案：fixed<M>x<N>是有符号的固定小数点数，ufixed<M>x<N>而是无符号的固定小数点数。其中M是总点数，N是小数点数。

事件的ABI编码如何处理已索引和未索引的参数？
答案：已索引的参数将与事件的 Keccak 哈希一起作为日志项的主题存储。未索引的参数则存储在日志的数据部分。

描述如何通过 ABI 对一个返回错误的函数进行编码。
答案：错误函数的编码与普通函数相似，但使用错误选择器。例如，InsufficientBalance错误将编码其参数并使用特定的错误选择器。

abi.encodePacked()在什么情况下使用，它有abi.encode()什么区别？
答案：abi.encodePacked()用于非标准模式备份，适用于需要紧凑编码的情况。它的abi.encode()主要区别是不会对短于 32 字节的类型进行补 0 操作，且动态类型不包含长度信息。

解释 ABI 中对动态阵列编码的过程。
答案：动态队列首先编码阵列总长度，然后编码阵列中每个元素。如果元素是动态类型，则对每个元素进行独立编码，并记录其偏移。

如何在 ABI 中处理废水或结构体？
答案：托盘或结构体按其元素顺序编码，每个元素根据其类型（静态或动态）适当处理。动态元素会记录偏移量，然后编码其内容。